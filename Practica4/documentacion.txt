/**

  \mainpage Exercise Documentation

  \author Luis Gonzalez Varela
  \version Practica 4

  \section SEC_OBS Contenido
  - Actividad 4.1. Contador concurrente.
  - Actividad 4.2. Calculadora de matrices.
  - Actividad 4.3. Ping Pong.

  \page PAGE_DOCU_1 Documentacion 4.1

  \author Luis Gonzalez Varela
  \version Ejercicio 4.1

  \section SEC_OBS Observaciones y Cuestiones

  - ¿Podemos garantizar que cuando un hilo ejecuta el método Incrementar(), no interferirá con otro hilo? ¿Cómo podemos solucionarlo?\n
  En principio no podemos garantizar que no haya interferencias sin implementar algún tipo de semáforo o candado.\n Dos hilos no pueden sumar al mismo tiempo pero si que pueden intercalarse entre suma y suma. \n

  \page PAGE_DOCU_2 Documentacion 4.2

  \author Luis Gonzalez Varela
  \version Ejercicio 4.2

  \section SEC_OBS Observaciones y Cuestiones
  Nota: No ha sido necesario implementar ninguna estructura de control ya que no es posible que se produzcan colisiones en la escritura de la matriz resultado ni en los cálculos intermedios. \n
  Aunque puede ser implementado, dentro del paquete java.util.concurrent, un pool de hilos su implementación no aporta nada al funcionamiento del sistema ya que no se van a producir colisiones entre los hilos.\n
  Además sería necesario adaptar todo el código para gestionar dos pools diferentes en el caso de que la matriz tenga más filas que hilos existan para solucionar el problema y esto, aumentaría el tiempo de ejecución.\n\n
  * El programa trabaja con matrices cuadradas de m*m (el valor de m se recibe por consola) rellenandolas con valores aleatorios o con [1,0].
  * El programa viene configurado para que las matrices se rellenen con 1 pero solo hay que cambiar un parametro en las llamadas al metodo poblarMatriz.
  * El programa trabaja con n hilos de forma paralela (el valor de n se recibe por consola)
  *
  * La salida del programa que recibe dos matrices (A y B) está formada por la matriz resultado (C) que se imprime por pantalla junto con el tiempo que se ha invertido en la suma (al imprimir por pantalla las matrices el tiempo es mayor que si no se imprimieran las matrices).
  *
  * La funcion calcularSuma recibe dos matrices (A y B) y devuelve la suma en una tercera matriz (C).
  * Dependiendo del numero de hilos se ejecutan 4 estrategias distintas.
  -     1) (n == 1) Se crea un solo hilo que ejecuta un algoritmo secuencial clasico.
  -     2) (n >= m) && (n < m*m) Se opera un algoritmo que divide el trabajo por filas.
  -     3) (n >= m*m) Se opera con un algoritmo que divide el trabajo por sumas simples int + int = int entre los diferentes hilos.
  -     4) (n < m) && (n != 1) Se opera un algoritmo que asigna varias filas a un mismo hilo procurando un reparto uniforme.

  \page PAGE_DOCU_3 Documentacion 4.3

  \author Luis Gonzalez Varela
  \version Ejercicio 4.3

  \section SEC_OBS Observaciones y Cuestiones

  - Argumenta de forma semi-formal que tu programa es correcto y garantiza la semántica del juego.\n
  El programa ha sido codificado en base a las especificaciones de funcionamiento.\n Se utiliza compareAndSet para gestionar el acceso al recurso compartido. \n Es complicado demostrar mediante prints por pantalla que el programa funciona correctamente,\n pero su lógica parece correcta.

  - Mide el tiempo de ejecución (con un criterio de terminación razonable) de tu partido variando el\n número de jugadoras de unas pocas a unas miles. ¿Qué resultado esperas para un número constante\n de pasar-pelota independientemente del número de jugadores?\n ¿Qué dicen tus mediciones comparándolos con los resultados de la practica 3?\n ́
  Aparentemente este modelo de Ping Pong es más rapido que mediante el uso de candados. \n

  - ¿Funciona tu programa con una sola jugadora también? Si no lo hace ¿qué deberías cambiar?\n
  Si, no es necesario cambiar nada solo indicar que el numero de hilos es 1 en lugar de 15 (valor por defecto).\n
*/